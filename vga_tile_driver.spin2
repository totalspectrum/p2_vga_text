{{
'******************************
'*  VGA tiled image driver
'******************************

Runs in its own COG. See README.txt for theory of operation.

Two variants are provided: an 8 bit palette version and a 32 bit
full color. To select the 8 bit version pass "4" (4 bytes per pixel)
for the bytes_per_char parameter; for 32 bit pass "8"

}}

CON
  intensity = 80    '0..128


DAT     
        org 0

entry
	' read parameters
basepin_val
	rdlong	basepin_val, ptra++
buffer_base
        rdlong  buffer_base, ptra++
text_cols
	rdlong  text_cols, ptra++
text_rows
	rdlong  text_rows, ptra++
font_base
        rdlong	font_base, ptra++
font_width
        rdlong  font_width, ptra++
font_height
	rdlong  font_height, ptra++
fpix_scale
        rdlong  fpix_scale, ptra++
hfront_porch
	rdlong  hfront_porch, ptra++
hsync_pulse
        rdlong  hsync_pulse, ptra++
hback_porch
	rdlong  hback_porch, ptra++
vfront_porch
	rdlong  vfront_porch, ptra++
vsync_pulse
	rdlong  vsync_pulse, ptra++
vback_porch
	rdlong  vback_porch, ptra++
polarity
        rdlong  polarity, ptra++
	' this must be either 8 (for 32 bit color) or 4 (for 8 bit color)
bytes_per_char
	rdlong	bytes_per_char, ptra++
'
' Setup 
'
' this code can be overwritten once we are going
'

vga_start
        ' calculate things based on parameters
char_cnt
	mov	char_cnt, text_cols
strikethru_line
	shr	char_cnt, #1		' we process 2 characters at a time
vsync_val
	mov	strikethru_line, font_height
stride
	shr	strikethru_line, #1	' divide height by 2
stride_chunks
        mov	stride, text_cols
hpixels
        mul     stride, bytes_per_char
vpixels
        mov     stride_chunks, stride
buffer_ptr
        add     stride_chunks, #63
font_ptr
        shr     stride_chunks, #6 ' divide by 64
mycogid
        mov     hpixels, text_cols
font_line_counter
        mul     hpixels, font_width
x
        mov     vpixels, text_rows
y
        mul     vpixels, font_height

	' copy parameters into settings
curchar
	add	m_rf_even, font_width
cureff
	add	m_rf_odd, font_width
bgcolor
	add	m_bs, hfront_porch
fgcolor
	add	m_sn, hsync_pulse
	add	m_bv, hback_porch
	add	m_vi, hpixels

	' put our COG id into the DAC info
	cogid	mycogid
	shl	mycogid, #8
	or 	dacmode_s, mycogid
	or	dacmode_c, mycogid

        setxfrq fpix_scale       'set transfer frequency
	mov	vsync_val, basepin_val
	add	vsync_val, #4
	
        ' set up initial polarity
        test    polarity, #%10 wc
        drvc    vsync_val
        test    polarity, #1 wc
	' NOTE: the setcmod instruction puts its argument in the D field (bits 9-17)
	' so to set the low bit of the argument, we need to set bit 9 of the instruction
        bitc    cmodval, #9		' set bit for cmodval
	
        'set up level scaling
        setcy   ##intensity << 24   'r  set colorspace for rgb
        setci   ##intensity << 16   'g
        setcq   ##intensity << 08   'b
cmodval
	setcmod #%01_0_000_0             'enable colorspace conversion; note low bit is set above

        'RJA dacmodes changed for real P2
        wrpin   dacmode_s,basepin_val      'enable dac modes in pins 0..3
	dirh	basepin_val
	add	basepin_val, #1
        wrpin   dacmode_c,basepin_val
	dirh	basepin_val
	add	basepin_val, #1
        wrpin   dacmode_c,basepin_val
	dirh	basepin_val
	add	basepin_val, #1
        wrpin   dacmode_c,basepin_val
	dirh	basepin_val

	' change bytes_per_char into a flag: 0 means 8bpp, non-zero means 32bpp color
	sub	 bytes_per_char, #4
'
'
' Field loop
'
field   
	mov     y,vfront_porch           'top blanks
        call    #blank
	mov	buffer_ptr, buffer_base
	mov	font_ptr, font_base
	mov	font_line_counter, font_height
	add	field_count, #1
	test	field_count, #32 wz
  if_z	mov	field_effects, #$ff
  if_nz mov	field_effects, #$0f
  
        mov     y,vpixels          'set visible line
line    
        call    #hsync          'do horizontal sync; also loads up next font line

	' now read the character data
	' this is stored as 8 byte per character;
	' two longs, first containing 24 bit color + character glyph,
        ' second containing the 24 bit color and a reserved field
	rdfast stride_chunks, buffer_ptr

	sub	font_line_counter, #1 wz
if_z	mov	font_line_counter, font_height
if_z	mov	font_ptr, font_base
if_z	add	buffer_ptr, stride ' next line

	'' check for effects on this line
	mov	line_effects, #$91
	cmp	font_line_counter, #1 wz
if_z	or	line_effects, #$22
	cmp	font_line_counter, strikethru_line wz
if_z    or	line_effects, #$44

	'' turn off blink specific stuff
	and	line_effects, field_effects

	''
	'' the main loop processes 2 characters (16 pixels) at a time,
	'' ping-ponging between even and odd
	''
	' we use LUT elements 0,1 and 32,33 to hold the colors, ping-ponging back
	' between them
	' we have to use 32,33 because the granularity of changing the streamer
	' LUT pointer is 5 bits
	
	tjz	bytes_per_char, #do_byte_loop
	
	rep	@end_32bppchar, char_cnt
next_32bppchar
	' handles 8x2 pixels at a time
	' at 65 MHz pixel clock and 200 MHz system clock, we have 3 cycles/pixel or 1.5 instructions/pixel
	' so this loop must not be more than 24 instructions

	'' even pixel
	rflong	fgcolor
	rflong	bgcolor
	getbyte curchar, fgcolor, #0
	test	bgcolor, line_effects wz
	
	andn	fgcolor, #$FF
	andn	bgcolor, #$FF
	altgb	curchar, #font_line	' fetch from font table
	getbyte	curchar

  if_nz or	curchar, #$ff		' if effect mask active add a line
	xcont	m_rf_even, curchar
	wrlut	bgcolor, #0
	wrlut	fgcolor, #1

	'' odd pixel
	rflong	fgcolor
	rflong	bgcolor
	getbyte curchar, fgcolor, #0
	test	bgcolor, line_effects wz
	
	andn	fgcolor, #$FF
	andn	bgcolor, #$FF ' handle in the glyphat code
	altgb	curchar, #font_line	' fetch from font table
	getbyte	curchar
	
  if_nz or	curchar, #$ff		' if effect mask active add a line
	xcont	m_rf_odd, curchar
	wrlut	bgcolor, #32
	wrlut	fgcolor, #33
	
	'' 
	'' end of loop
end_32bppchar
        djnz    y,#line         'another line?
	jmp	#end_of_line

do_byte_loop

	rep	@end_8bppchar, char_cnt
next_8bppchar
	' handles 8x2 pixels at a time
	' at 65 MHz pixel clock and 200 MHz system clock, we have 3 cycles/pixel or 1.5 instructions/pixel
	' so this loop must not be more than 24 instructions

	'' even pixel
	rfbyte	fgcolor
	rfbyte	bgcolor
	rfbyte	curchar
	rfbyte	cureff

	' do table lookup on colors
	alts	fgcolor, #color_Palette
	mov	fgcolor, 0-0
	alts	bgcolor, #color_Palette
	mov	bgcolor, 0-0
	
	altgb	curchar, #font_line	' fetch from font table
	getbyte	curchar
	and	cureff, line_effects wz	
	test	cureff, #$80 wc
	
  if_nz	muxnc	curchar, #$ff		' if effect mask active add a line
	xcont	m_rf_even, curchar
	wrlut	bgcolor, #0
	wrlut	fgcolor, #1

	'' odd pixel
	rfbyte	fgcolor
	rfbyte	bgcolor
	rfbyte	curchar
	rfbyte	cureff

	' do table lookup on colors
	alts	fgcolor, #color_Palette
	mov	fgcolor, 0-0
	alts	bgcolor, #color_Palette
	mov	bgcolor, 0-0
	
	altgb	curchar, #font_line	' fetch from font table
	getbyte	curchar
	and	cureff, line_effects wz	
	test	cureff, #$80 wc
	
  if_nz muxnc	curchar, #$ff		' if effect mask active add a line
	xcont	m_rf_odd, curchar
	wrlut	bgcolor, #32
	wrlut	fgcolor, #33
	
	'' 
	'' end of loop
end_8bppchar
        djnz    y,#line         'another line?

end_of_line
        mov	y,vback_porch           'bottom blanks
        call    #blank

        drvnot  vsync_val          'sync on

        mov 	y,vsync_pulse            'sync blanks
        call    #blank

        drvnot  vsync_val          'sync off

        jmp     #field                  'loop

	'' 8bpp character loop
	
'
'
' Subroutines
'
blank       call    #hsync          'blank lines
            xcont   m_vi,#0
    _ret_   djnz    y,#blank

hsync       xcont   m_bs,#0         'horizontal sync
            xcont   m_sn,#1
	xcont m_bv, #0
	setq	#63		' read 64 longs = 256 bytes from font table
	rdlong	font_line, font_ptr
  _ret_	add	font_ptr, #256

'
'
' Initialized data
'RJA:  New dacmodes for real P2
dacmode_s       long    %0000_0000_000_1011000000000_01_00000_0         'hsync is 123-ohm, 3.3V
dacmode_c       long    %0000_0000_000_1011100000000_01_00000_0         'R/G/B are 75-ohm, 2.0V

m_bs        long    $CF000000 {+HFRONT_PORCH}        'before sync
m_sn        long    $CF000000 {+HSYNC}        'sync
m_bv        long    $CF000000 {+HBACK_PORCH}        'before visible
m_vi        long    $CF000000 {+HPIXELS}       'visible

m_rf_even    long   $8F000000 {+FONT_WIDTH}     ' 1bpp
m_rf_odd     long   $8F010000 {+FONT_WIDTH}     ' 1bpp LUT immediate

' active character effects for this line
' these bits have the following meanings:
'    01 = hide (show all fgground color)
'    02 = underline
'    04 = strikethrough
'    08 = reserved
'    10 = blinking hide
'    20 = blinking underline
'    40 = blinking strikethrough
'    80 = if hidden, use bgcolor instead of fgcolor

line_effects	long 0

' active effects for this field; the blinking ones will be turned off
' on half of the fields
field_effects   long 0

' count of elapsed fields, used for blinking
field_count	long	0

	     ' standard ANSI 256 color palette
color_palette
	long	$00000000, $80000000, $00800000, $80800000, $00008000, $80008000, $00808000, $c0c0c000
	long	$80808000, $ff000000, $00ff0000, $ffff0000, $0000ff00, $ff00ff00, $00ffff00, $ffffff00
	long	$00000000, $00000100, $00000200, $00000300, $00000400, $00000500, $00010000, $00010100
	long	$00010200, $00010300, $00010400, $00010500, $00020000, $00020100, $00020200, $00020300
	long	$00020400, $00020500, $00030000, $00030100, $00030200, $00030300, $00030400, $00030500
	long	$00040000, $00040100, $00040200, $00040300, $00040400, $00040500, $00050000, $00050100
	long	$00050200, $00050300, $00050400, $00050500, $01000000, $01000100, $01000200, $01000300
	long	$01000400, $01000500, $01010000, $01010100, $01010200, $01010300, $01010400, $01010500
	long	$01020000, $01020100, $01020200, $01020300, $01020400, $01020500, $01030000, $01030100
	long	$01030200, $01030300, $01030400, $01030500, $01040000, $01040100, $01040200, $01040300
	long	$01040400, $01040500, $01050000, $01050100, $01050200, $01050300, $01050400, $01050500
	long	$02000000, $02000100, $02000200, $02000300, $02000400, $02000500, $02010000, $02010100
	long	$02010200, $02010300, $02010400, $02010500, $02020000, $02020100, $02020200, $02020300
	long	$02020400, $02020500, $02030000, $02030100, $02030200, $02030300, $02030400, $02030500
	long	$02040000, $02040100, $02040200, $02040300, $02040400, $02040500, $02050000, $02050100
	long	$02050200, $02050300, $02050400, $02050500, $03000000, $03000100, $03000200, $03000300
	long	$03000400, $03000500, $03010000, $03010100, $03010200, $03010300, $03010400, $03010500
	long	$03020000, $03020100, $03020200, $03020300, $03020400, $03020500, $03030000, $03030100
	long	$03030200, $03030300, $03030400, $03030500, $03040000, $03040100, $03040200, $03040300
	long	$03040400, $03040500, $03050000, $03050100, $03050200, $03050300, $03050400, $03050500
	long	$04000000, $04000100, $04000200, $04000300, $04000400, $04000500, $04010000, $04010100
	long	$04010200, $04010300, $04010400, $04010500, $04020000, $04020100, $04020200, $04020300
	long	$04020400, $04020500, $04030000, $04030100, $04030200, $04030300, $04030400, $04030500
	long	$04040000, $04040100, $04040200, $04040300, $04040400, $04040500, $04050000, $04050100
	long	$04050200, $04050300, $04050400, $04050500, $05000000, $05000100, $05000200, $05000300
	long	$05000400, $05000500, $05010000, $05010100, $05010200, $05010300, $05010400, $05010500
	long	$05020000, $05020100, $05020200, $05020300, $05020400, $05020500, $05030000, $05030100
	long	$05030200, $05030300, $05030400, $05030500, $05040000, $05040100, $05040200, $05040300
	long	$05040400, $05040500, $05050000, $05050100, $05050200, $05050300, $05050400, $05050500
	long	$08080800, $12121200, $1c1c1c00, $26262600, $30303000, $3a3a3a00, $44444400, $4e4e4e00
	long	$58585800, $62626200, $6c6c6c00, $76767600, $80808000, $8a8a8a00, $94949400, $9e9e9e00
	long	$a8a8a800, $b2b2b200, $bcbcbc00, $c6c6c600, $d0d0d000, $dadada00, $e4e4e400, $eeeeee00
	

' space for 256 bytes of font data
font_line res 64

	fit $1f0         ' make sure it all fits in COG

'******************************************************************
'* Spin interfaces
'******************************************************************

VAR
  long mycog

PUB start(params)
  mycog := cognew(@entry, params) + 1
  return mycog

PUB stop
  if mycog
    cogstop(mycog-1)
    mycog := 0

''
'' utility function
'' calculates proper pixel scaling for
'' pixel clock frequency a and system clock frequency b
''

'
' calculate ($8000_0000 * a) / (b)
'
CON PIXSHIFT = 31

PUB calcscale(a, b) | shiftcnt
  shiftcnt := PIXSHIFT
  ' remove factors of 5 (will be pretty common)
  repeat while 0 == (a // 5) and 0 == (b // 5)
    a := a / 5
    b := b / 5

  ' scale a up as much as we can
  repeat while ((a & $4000_0000) == 0) and shiftcnt > 0
    a := a << 1
    shiftcnt--
  repeat while ((b & 1) == 0) and shiftcnt > 0
    b := b>>1
    shiftcnt--
  return (a / b) << shiftcnt
